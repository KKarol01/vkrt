#pragma once

#include <span>
#include <vector>
#include <array>
#include <stack>
#include <type_traits>
#include <atomic>
#include <cstdint>
#include <memory>
#include <optional>
#include <bitset>
#include <iterator>
#include <tuple>
#include <algorithm>
#include <limits>
#include <eng/common/sparseset.hpp>
#include <eng/common/slotmap.hpp>
#include <eng/common/slotallocator.hpp>
#include <eng/common/indexed_hierarchy.hpp>
#include <eng/common/logger.hpp>
#include <eng/common/callback.hpp>
#include <eng/common/hash.hpp>

namespace eng
{
namespace ecs
{

using component_id = uint32_t;

// This is the client's versioned handle. Internally it's made from entity_t
struct entity_t;
struct view_id_t;
struct entity_id : public TypedIntegral<entity_id, uint64_t>
{
    explicit entity_id() : entity_id(~0u, ~0u) {}
    explicit entity_id(storage_type raw_value) : TypedIntegral(raw_value) {}
    entity_id(uint32_t slot, uint32_t version) : TypedIntegral(((uint64_t)version << 32) | (uint64_t)slot) {}
    auto operator<=>(const entity_id&) const = default;
    uint32_t slot() const { return (uint32_t)handle; }
    uint32_t version() const { return (uint32_t)(handle >> 32); }
};
using view_id = TypedIntegral<view_id_t, component_id>;
using entity = TypedIntegral<entity_t, uint32_t>;

inline static constexpr size_t MAX_COMPONENTS = std::numeric_limits<component_id>::digits;
inline std::atomic_uint32_t component_id_generator{};

using signature = std::bitset<MAX_COMPONENTS>;
using component_update_callback_t = void(entity_id eid, signature updated);
// using component_delete_callback_t = Callback<void(entity_id eid)>; // no delete for now

} // namespace ecs
} // namespace eng

ENG_DEFINE_STD_HASH(eng::ecs::entity_id, *t);
ENG_DEFINE_STD_HASH(eng::ecs::entity, *t);

namespace eng
{
namespace ecs
{

struct IComponentPool
{
    virtual ~IComponentPool() = default;
    virtual void erase(entity e) = 0;
    SparseSet<entity::storage_type, 1024> entities; // for packing components
};

template <typename Component> struct ComponentPool : public IComponentPool
{
    static size_t get_index()
    {
        static component_id _index = component_id_generator.fetch_add(1);
        return _index;
    }
    static component_id get_bit() { return component_id{ 1 } << get_index(); }

    Component& get(entity e)
    {
        const auto idx = entities.get(*e);
        if(!idx) { ENG_ERROR("Invalid entity {}", *e); }
        return components[*idx];
    }

    template <typename... Args> void emplace(entity e, Args&&... args)
    {
        const auto it = entities.insert(*e);
        if(!it)
        {
            ENG_ERROR("Overwriting entity {}", *e);
            return;
        }
        if(*it < components.size()) { std::construct_at<Component>(&components[*it], std::forward<Args>(args)...); }
        else
        {
            ENG_ASSERT(*it == components.size());
            components.emplace_back(std::forward<Args>(args)...);
        }
    }

    void erase(entity e) override
    {
        const auto it = entities.erase(*e);
        if(!it)
        {
            ENG_ERROR("Trying to delete invalid entity {}", *e);
            return;
        }
        components[*it] = std::move(components.back());
        components.pop_back();
    }

    std::vector<Component> components;
};

class Registry
{
    struct EntityMetadata
    {
        signature sig;
        IndexedHierarchy<entity_id>::element_id hierarchy_key;
        uint32_t version{};
    };

    struct View
    {
        signature sig;
        std::vector<entity_id> entities;
        Signal<component_update_callback_t> on_update_callbacks;
    };

    // For internal use. Generated by some counter.
    using entity_t = uint32_t;
    inline static constexpr size_t MAX_ENTITY = ~entity_t{};

    template <typename... Components> static signature get_signature()
    {
        return signature{ (ComponentPool<Components>::get_bit() | ...) };
    }

  public:
    bool has(entity_id eid) const { return entities.has(eid.slot()) && get_md(eid).version == eid.version(); }
    template <typename... Components> bool has(entity_id eid) const
    {
        const auto sig = get_signature<Components...>();
        return has(eid) && (get_md(eid).sig & sig) == sig;
    }

    entity_id create()
    {
        const auto eit = entities.insert();
        if(!eit)
        {
            ENG_ASSERT(false, "Too many entities");
            return entity_id{};
        }
        const auto slot = eit.sparse;
        if(slot == metadatas.size()) { metadatas.emplace_back(); }
        auto& md = metadatas[slot];
        const auto version = md.version;
        const auto eid = entity_id{ slot, version };
        md.hierarchy_key = hierarchy.insert(eid);
        return entity_id{ slot, version };
    }

    void erase(entity_id eid)
    {
        if(!has(eid))
        {
            ENG_ERROR("Tried to delete stale entity {}", *eid);
            return;
        }
        auto& md = get_md(eid);
        for(auto i = 0u; i < md.sig.size(); ++i)
        {
            if(md.sig.test(i)) { pools[i]->erase(entity{ eid.slot() }); }
        }
        auto it = entities.erase(eid.slot());
        ENG_ASSERT(it && it.sparse == eid.slot());
        hierarchy.erase(md.hierarchy_key);
        md = {};
        md.version = eid.version() + 1;
    }

    template <typename Component> Component& get(entity_id eid)
    {
        if(!has(eid))
        {
            static Component null_component = {};
            ENG_ERROR("Invalid entity {}", *eid);
            return null_component;
        }
        return get_pool<Component>().get(entity{ eid.slot() });
    }

    template <typename... Components> void add_components(entity_id eid, Components&&... components)
    {
        if(!has(eid))
        {
            ENG_ERROR("Invalid entity {}", *eid);
            return;
        }

        const signature sig{ (ComponentPool<Components>::get_bit() | ...) };
        auto& md = get_md(eid);
        if((sig & md.sig).any())
        {
            ENG_ERROR("Entity {} already has some of these components {}", *eid, (sig & md.sig).to_string());
            return;
        }

        const auto emplace_component = [this, eid]<typename T>(auto&& comp) {
            auto& pool = get_pool<T>();
            pool.emplace(entity{ eid.slot() }, std::forward<decltype(comp)>(comp));
        };
        const auto old_sig = md.sig;
        md.sig |= sig;
        (emplace_component.template operator()<Components>(std::forward<Components>(components)), ...);
        on_entity_sig_change(eid, old_sig, md.sig);
    }

    template <typename... Components> void erase_components(entity_id eid)
    {
        const signature sig{ (ComponentPool<Components>::get_bit() | ...) };
        auto& md = get_md(eid);
        ENG_ASSERT((md.sig & sig) == sig);

        ENG_ASSERT(false, "Implement removing from view");

        const auto remove_component = [this, eid]<typename T>() {
            auto& pool = get_pool<T>();
            pool.erase(entity{ eid.slot() });
        };
        (remove_component.template operator()<Components>(), ...);
        md.sig &= ~sig;
    }

    void make_child(entity_id parentid, entity_id childid)
    {
        if(!has(parentid))
        {
            ENG_ERROR("Entity {} is invalid", *parentid);
            return;
        }
        if(!has(childid))
        {
            ENG_ERROR("Entity {} is invalid", *childid);
            return;
        }
        hierarchy.make_child(get_md(parentid).hierarchy_key, get_md(childid).hierarchy_key);
    }

    entity_id get_parent(entity_id eid) const
    {
        if(!has(eid))
        {
            ENG_ERROR("Entity {} is invalid", *eid);
            return entity_id{};
        }
        const auto p = hierarchy.get_parent(get_md(eid).hierarchy_key);
        if(!p) { return entity_id{}; }
        return hierarchy.at(p);
    }

    bool has_children(entity_id eid) const
    {
        if(!has(eid))
        {
            ENG_ERROR("Entity {} is invalid", *eid);
            return false;
        }
        const auto& md = get_md(eid);
        return (bool)hierarchy.get_first_child(md.hierarchy_key);
    }

    void loop_over_children(entity_id eid, const auto& callback)
    {
        if(!has(eid))
        {
            ENG_ERROR("Entity {} is invalid", *eid);
            return;
        }
        auto first = hierarchy.get_first_child(get_md(eid).hierarchy_key);
        if(!first) { return; }
        auto child = first;
        do
        {
            auto next = hierarchy.get_next_sibling(child);
            callback(hierarchy.at(child));
            child = next;
        }
        while(child != first);
    }

    void traverse_hierarchy(entity_id eid, const auto& callback)
    {
        if(!has(eid))
        {
            ENG_ERROR("Entity {} is invalid", *eid);
            return;
        }
        const auto traverse = [&](entity_id id, const auto& self) -> void {
            callback(id);
            loop_over_children(id, [&](entity_id id) { self(id, self); });
        };
        traverse(eid, traverse);
    }

    template <typename... Components>
    void add_on_update(std::optional<Callback<component_update_callback_t>> on_update_callback = {})
    {
        const auto sig = get_signature<Components...>();
        const auto sigint = sig.to_ulong();
        if(!views.contains(sigint))
        {
            View view{};
            view.sig = sig;
            // can be nullptr if no components were inserted
            const IComponentPool* const smallest_component_pool = [this] {
                std::array<component_id, sizeof...(Components)> arr = { (component_id)ComponentPool<Components>::get_index()... };
                IComponentPool* smallest{};
                for(auto idx : arr)
                {
                    if(!smallest || pools[idx]->entities.size() < smallest->entities.size())
                    {
                        smallest = &*pools[idx];
                    }
                }
                return smallest;
            }();
            if(smallest_component_pool)
            {
                for(auto e : smallest_component_pool->entities)
                {
                    if(has<Components...>(entity_id{ e })) { view.entities.push_back(entity_id{ e }); }
                }
            }
            views.emplace(sigint, std::move(view));
        }
        auto& view = views.at(sigint);
        if(on_update_callback) { view.on_update_callbacks += *on_update_callback; }
    }

    template <typename... Components> void notify_update(entity_id eid)
    {
        const auto sig = get_signature<Components...>();
        for(const auto& [viewsig, view] : views)
        {
            if((viewsig & sig).any()) { view.on_update_callbacks.signal(eid, sig); }
        }
    }

  private:
    EntityMetadata& get_md(entity_id eid) { return metadatas[eid.slot()]; }
    const EntityMetadata& get_md(entity_id eid) const { return metadatas[eid.slot()]; }

    template <typename Component> ComponentPool<Component>& get_pool()
    {
        const auto idx = ComponentPool<Component>::get_index();
        if(!pools[idx]) { pools[idx] = std::make_unique<ComponentPool<Component>>(); }
        return *static_cast<ComponentPool<Component>*>(&*pools[idx]);
    }

    void on_entity_sig_change(entity_id eid, signature old_sig, signature new_sig)
    {
        for(auto& [viewsig, view] : views)
        {
            const auto old_sig_passed = (viewsig & old_sig) == viewsig;
            const auto new_sig_passes = (viewsig & new_sig) == viewsig;
            if(!old_sig_passed && new_sig_passes) { view.entities.push_back(eid); }
            else if(old_sig_passed && !new_sig_passes) { ENG_ASSERT(false, "Implement entity removing"); }
        }
    }

    SparseSet<entity::storage_type> entities;
    IndexedHierarchy<entity_id> hierarchy;
    std::vector<EntityMetadata> metadatas;
    std::array<std::unique_ptr<IComponentPool>, MAX_COMPONENTS> pools;
    std::unordered_map<signature, View> views;
};

} // namespace ecs
} // namespace eng
