#pragma once

#include <span>
#include <vector>
#include <array>
#include <stack>
#include <type_traits>
#include <atomic>
#include <cstdint>
#include <memory>
#include <optional>
#include <bitset>
#include <iterator>
#include <tuple>
#include <algorithm>
#include <limits>
#include <eng/common/sparseset.hpp>
#include <eng/common/slotmap.hpp>
#include <eng/common/slotallocator.hpp>
#include <eng/common/indexed_hierarchy.hpp>
#include <eng/common/logger.hpp>
#include <eng/common/callback.hpp>
#include <eng/common/hash.hpp>

namespace eng
{
namespace ecs
{

struct slot_t;
using slot_id = TypedId<slot_t, uint32_t>;
struct entity_id : public TypedId<entity_id, uint64_t>
{
    explicit entity_id(storage_type handle) : TypedId(handle) {}
    explicit entity_id() : entity_id(slot_id{}, ~0u) {}
    entity_id(slot_id slot, uint32_t version) : TypedId(((uint64_t)version << 32) | (uint64_t)*slot) {}
    auto operator<=>(const entity_id&) const = default;
    slot_id get_slot() const { return slot_id{ (uint32_t)handle }; }
    uint32_t get_version() const { return (uint32_t)(handle >> 32); }
};
using component_id = uint32_t;
inline static constexpr uint32_t MAX_COMPONENTS = std::numeric_limits<component_id>::digits;
struct view_id_t;
using view_id = TypedId<view_id_t, component_id>;
using signature = std::bitset<MAX_COMPONENTS>;
using view_on_entity_insert_t = void(entity_id eid);
using view_on_entity_update_t = void(entity_id eid, signature updated);
using view_on_entity_remove_t = void(entity_id eid);
using component = void(entity_id eid, signature updated);

struct ComponentTraits
{
    template <typename Component> static component_id get_id()
    {
        static auto id = counter.fetch_add(1);
        ENG_ASSERT(id < MAX_COMPONENTS);
        return id;
    }
    template <typename... Components> static signature get_signature()
    {
        return signature{ (0 | ... | (1ull << get_id<Components>())) };
    }
    inline static std::atomic<component_id> counter{};
};

template <typename... Components> inline bool test_signature(signature sig)
{
    const auto csig = ComponentTraits::get_signature<Components...>();
    return (csig & sig) == csig;
}

} // namespace ecs
} // namespace eng

ENG_DEFINE_STD_HASH(eng::ecs::entity_id, *t);
ENG_DEFINE_STD_HASH(eng::ecs::slot_id, *t);

namespace eng
{
namespace ecs
{

struct IComponentPool
{
    virtual ~IComponentPool() = default;
    bool has(slot_id e) const { return entities.has(*e); }
    virtual void erase(slot_id e) = 0;
    SparseSet<slot_id::storage_type, 1024> entities; // for packing components
};

template <typename Component> struct ComponentPool : public IComponentPool
{
    Component& get(slot_id e)
    {
        const auto idx = entities.get(*e);
        if(!idx) { ENG_ERROR("Invalid entity {}", *e); }
        return components[*idx];
    }

    template <typename... Args> void emplace(slot_id e, Args&&... args)
    {
        const auto it = entities.insert(*e);
        if(!it)
        {
            ENG_ERROR("Overwriting entity {}", *e);
            return;
        }
        if(*it < components.size()) { std::construct_at<Component>(&components[*it], std::forward<Args>(args)...); }
        else
        {
            ENG_ASSERT(*it == components.size());
            components.emplace_back(std::forward<Args>(args)...);
        }
    }

    void erase(slot_id e) override
    {
        const auto it = entities.erase(*e);
        if(!it)
        {
            ENG_ERROR("Trying to delete invalid entity {}", *e);
            return;
        }
        components[*it] = std::move(components.back());
        components.pop_back();
    }

    std::vector<Component> components;
};

class Registry
{
    struct EntityMetadata
    {
        signature sig;
        IndexedHierarchy<entity_id>::element_id hierarchy_key;
        uint32_t version{};
    };

    struct View
    {
        // checks if an entity with given signature has required components by the view
        bool test_sig(signature esig) const { return (sig & esig) == sig; }
        signature sig;
        std::vector<entity_id> entities;
        Signal<view_on_entity_insert_t> on_insert_callbacks;
        Signal<view_on_entity_update_t> on_update_callbacks;
        Signal<view_on_entity_remove_t> on_remove_callbacks;
    };

    // For internal use. Generated by some counter.
    using entity_t = uint32_t;
    inline static constexpr size_t MAX_ENTITY = ~entity_t{};

    template <typename... Components> static signature get_signature()
    {
        return (ComponentTraits::get_signature<Components>() | ...);
    }

  public:
    bool has(entity_id eid) const { return slots.has(*eid.get_slot()) && eid.get_version() == get_md(eid).version; }
    template <typename... Components> bool has(entity_id eid) const
    {
        const auto sig = get_signature<Components...>();
        return has(eid) && (get_md(eid).sig & sig) == sig;
    }

    entity_id create()
    {
        const auto slot = slot_id{ slots.allocate() };
        if(!slot)
        {
            ENG_ASSERT(false, "Too many entities");
            return entity_id{};
        }
        if(*slot == metadatas.size()) { metadatas.emplace_back(); }
        auto& md = metadatas[*slot];
        const auto version = md.version;
        const auto eid = entity_id{ slot, version };
        md.hierarchy_key = hierarchy.insert(eid);
        return entity_id{ slot, version };
    }

    void erase(entity_id eid)
    {
        if(!has(eid))
        {
            ENG_ERROR("Tried to delete stale entity {}", *eid);
            return;
        }
        erase_components(eid);
        auto& md = get_md(eid);
        slots.erase(*eid.get_slot());
        hierarchy.erase(md.hierarchy_key);
        md = {};
        md.version = eid.get_version() + 1;
    }

    template <typename Component> Component& get(entity_id eid)
    {
        if(!has(eid))
        {
            static Component null_component = {};
            ENG_ERROR("Invalid entity {}", *eid);
            return null_component;
        }
        return get_pool<Component>().get(eid.get_slot());
    }

    template <typename... Components> void add_components(entity_id eid, Components&&... components)
    {
        if(!has(eid))
        {
            ENG_ERROR("Invalid entity {}", *eid);
            return;
        }

        const signature sig = ComponentTraits::get_signature<Components...>();
        auto& md = get_md(eid);
        if((sig & md.sig).any())
        {
            ENG_ERROR("Entity {} already has some of these components {}", *eid, (sig & md.sig).to_string());
            return;
        }

        const auto emplace_component = [this, eid]<typename T>(auto&& comp) {
            auto& pool = get_pool<T>();
            pool.emplace(eid.get_slot(), std::forward<decltype(comp)>(comp));
        };
        const auto old_sig = md.sig;
        md.sig |= sig;
        (emplace_component.template operator()<Components>(std::forward<Components>(components)), ...);
        on_entity_sig_change(eid, old_sig, md.sig);
    }

    template <typename... Components> void erase_components(entity_id eid)
    {
        try_erase_components(eid, ComponentTraits::get_signature<Components...>());
    }

    void make_child(entity_id parentid, entity_id childid)
    {
        if(!has(parentid))
        {
            ENG_ERROR("Entity {} is invalid", *parentid);
            return;
        }
        if(!has(childid))
        {
            ENG_ERROR("Entity {} is invalid", *childid);
            return;
        }
        hierarchy.make_child(get_md(parentid).hierarchy_key, get_md(childid).hierarchy_key);
    }

    entity_id get_parent(entity_id eid) const
    {
        if(!has(eid))
        {
            ENG_ERROR("Entity {} is invalid", *eid);
            return entity_id{};
        }
        const auto p = hierarchy.get_parent(get_md(eid).hierarchy_key);
        if(!p) { return entity_id{}; }
        return hierarchy.at(p);
    }

    bool has_children(entity_id eid) const
    {
        if(!has(eid))
        {
            ENG_ERROR("Entity {} is invalid", *eid);
            return false;
        }
        const auto& md = get_md(eid);
        return (bool)hierarchy.get_first_child(md.hierarchy_key);
    }

    void loop_over_children(entity_id eid, const auto& callback)
    {
        if(!has(eid))
        {
            ENG_ERROR("Entity {} is invalid", *eid);
            return;
        }
        auto first = hierarchy.get_first_child(get_md(eid).hierarchy_key);
        if(!first) { return; }
        auto child = first;
        do
        {
            auto next = hierarchy.get_next_sibling(child);
            callback(hierarchy.at(child));
            child = next;
        }
        while(child != first);
    }

    void traverse_hierarchy(entity_id eid, const auto& callback)
    {
        if(!has(eid))
        {
            ENG_ERROR("Invalid entity {}", *eid.get_slot());
            return;
        }
        const auto traverse = [&](entity_id id, const auto& self) -> void {
            callback(id);
            loop_over_children(id, [&](entity_id id) { self(id, self); });
        };
        traverse(eid, traverse);
    }

    template <typename... Components>
    void register_callbacks(std::optional<Callback<view_on_entity_insert_t>> on_insert_callback = {},
                            std::optional<Callback<view_on_entity_update_t>> on_update_callback = {},
                            std::optional<Callback<view_on_entity_remove_t>> on_remove_callback = {})
    {
        const auto sig = get_signature<Components...>();
        if(!views.contains(sig))
        {
            View view{};
            view.sig = sig;
            // can be nullptr if no components were inserted
            const IComponentPool* const smallest_component_pool = [this] {
                std::array<component_id, sizeof...(Components)> arr = { ComponentTraits::get_id<Components>()... };
                IComponentPool* smallest{};
                for(auto idx : arr)
                {
                    if(!smallest || pools[idx]->entities.size() < smallest->entities.size())
                    {
                        smallest = &*pools[idx];
                    }
                }
                return smallest;
            }();
            if(smallest_component_pool)
            {
                for(auto e : smallest_component_pool->entities)
                {
                    const auto eid = entity_id{ slot_id{ e }, metadatas[e].version };
                    if(has<Components...>(eid)) { view.entities.push_back(eid); }
                }
            }
            views.emplace(sig, std::move(view));
        }
        auto& view = views.at(sig);
        if(on_insert_callback) { view.on_insert_callbacks += *on_insert_callback; }
        if(on_update_callback) { view.on_update_callbacks += *on_update_callback; }
        if(on_remove_callback) { view.on_remove_callbacks += *on_remove_callback; }
    }

    template <typename... Components> void signal_components_update(entity_id eid)
    {
        notify_entity_views(eid, get_signature<Components...>());
    }

  private:
    EntityMetadata& get_md(entity_id eid) { return metadatas[*eid.get_slot()]; }
    const EntityMetadata& get_md(entity_id eid) const { return metadatas[*eid.get_slot()]; }

    void try_erase_components(entity_id eid, signature sig)
    {
        if(!has(eid))
        {
            ENG_ERROR("Invalid entity {}", *eid.get_slot());
            return;
        }
        signature remsig = {};
        for(auto i = 0ull; i < sig.size(); ++i)
        {
            if(sig[i] && pools[i]->has(eid.get_slot()))
            {
                remsig.set(i);
                pools[i]->erase(eid.get_slot());
            }
        }
        auto& md = get_md(eid);
        const auto newsig = md.sig & (~remsig);
        on_entity_sig_change(eid, md.sig, newsig);
        md.sig = newsig;
    }

    template <typename Component> ComponentPool<Component>& get_pool()
    {
        const auto id = ComponentTraits::get_id<Component>();
        if(!pools[id]) { pools[id] = std::make_unique<ComponentPool<Component>>(); }
        return *static_cast<ComponentPool<Component>*>(&*pools[id]);
    }

    void on_entity_sig_change(entity_id eid, signature old_sig, signature new_sig)
    {
        for(auto& [viewsig, view] : views)
        {
            const auto old_sig_passed = view.test_sig(old_sig);
            const auto new_sig_passes = view.test_sig(new_sig);
            if(!old_sig_passed && new_sig_passes)
            {
                view.entities.push_back(eid);
                view.on_insert_callbacks.signal(eid);
            }
            else if(old_sig_passed && !new_sig_passes)
            {
                const auto rem = std::erase(view.entities, eid);
                ENG_ASSERT(rem == 1);
                view.on_remove_callbacks.signal(eid);
            }
        }
    }

    void notify_entity_views(entity_id eid, signature updated_comps)
    {
        for(auto& [viewsig, view] : views)
        {
            if((updated_comps & view.sig).any() && view.test_sig(get_md(eid).sig))
            {
                view.on_update_callbacks.signal(eid, updated_comps);
            }
        }
    }

    SlotAllocator slots;
    std::vector<EntityMetadata> metadatas;
    IndexedHierarchy<entity_id> hierarchy;
    std::array<std::unique_ptr<IComponentPool>, MAX_COMPONENTS> pools;
    std::unordered_map<signature, View> views;
};

} // namespace ecs
} // namespace eng
