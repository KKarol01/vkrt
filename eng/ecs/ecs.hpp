#pragma once

#include <span>
#include <vector>
#include <array>
#include <stack>
#include <type_traits>
#include <atomic>
#include <cstdint>
#include <memory>
#include <optional>
#include <bitset>
#include <iterator>
#include <tuple>
#include <algorithm>
#include <limits>
#include <eng/common/sparseset.hpp>
#include <eng/common/slotmap.hpp>
#include <eng/common/slotallocator.hpp>
#include <eng/common/indexed_hierarchy.hpp>
#include <eng/common/logger.hpp>
#include <eng/common/callback.hpp>
#include <eng/common/hash.hpp>

namespace eng
{
namespace ecs
{
/*
    Ecs is a system that generates handles (64 bit for now, but could be compressed)
    and allows users to attach structures to them which can be queried later.
    Each handle has 32bit versioning number which is used to prevent stale handles
    when it's been recycled when doing create->erase->create. During erase version is
    bumped by 1.

    Typical usage is as follows:
    e = create()
    add_components<A, B, C, ...>(e, A{}, B{}, C{}, ...)

    Then some system may wish to iterate over all registered components of type A{}.
    Let's assume it's Transform component.
    It would do as follows

*/

struct Slot;
using SlotId = TypedId<Slot, uint32_t>;
struct EntityId : public TypedId<EntityId, uint64_t>
{
    explicit EntityId(storage_type handle) : TypedId(handle) {}
    explicit EntityId() : EntityId(SlotId{}, ~0u) {}
    EntityId(SlotId slot, uint32_t version) : TypedId(((uint64_t)version << 32) | (uint64_t)*slot) {}
    auto operator<=>(const EntityId&) const = default;
    SlotId get_slot() const { return SlotId{ (uint32_t)handle }; }
    uint32_t get_version() const { return (uint32_t)(handle >> 32); }
};
using ComponentId = uint32_t;
inline static constexpr uint32_t MAX_COMPONENTS = std::numeric_limits<ComponentId>::digits;
using Signature = std::bitset<MAX_COMPONENTS>;
using ViewEntityInsertedFunc = void(EntityId eid);
using ViewEntityUpdatedFunc = void(EntityId eid, Signature updated);
using ViewEntityRemovedFunc = void(EntityId eid);

struct ComponentTraits
{
    // Gets stable unique 0-based index for component
    template <typename Component> static ComponentId get_id()
    {
        static auto id = counter.fetch_add(1);
        ENG_ASSERT(id < MAX_COMPONENTS);
        return id;
    }
    // Returns bit mask of given components
    template <typename... Components> static Signature get_signature()
    {
        return Signature{ (0 | ... | (1ull << get_id<Components>())) };
    }
    inline static std::atomic<ComponentId> counter{};
};

template <typename... Components> inline bool test_signature(Signature sig)
{
    const auto csig = ComponentTraits::get_signature<Components...>();
    return (csig & sig) == csig;
}

struct IComponentPool
{
    virtual ~IComponentPool() = default;
    bool has(SlotId e) const { return entities.has(*e); }
    virtual void erase(SlotId e) = 0;
    SparseSet<SlotId::storage_type, 1024> entities; // for packing components
};

template <typename Component> struct ComponentPool : public IComponentPool
{
    Component& get(SlotId e)
    {
        const auto idx = entities.get(*e);
        if(!idx) { ENG_ERROR("Invalid entity {}", *e); }
        return components[*idx];
    }

    template <typename... Args> void emplace(SlotId e, Args&&... args)
    {
        const auto it = entities.insert(*e);
        if(!it)
        {
            ENG_ERROR("Overwriting entity {}", *e);
            return;
        }
        if(*it < components.size()) { std::construct_at<Component>(&components[*it], std::forward<Args>(args)...); }
        else
        {
            ENG_ASSERT(*it == components.size());
            components.emplace_back(std::forward<Args>(args)...);
        }
    }

    void erase(SlotId e) override
    {
        const auto it = entities.erase(*e);
        if(!it)
        {
            ENG_ERROR("Trying to delete invalid entity {}", *e);
            return;
        }
        components[*it] = std::move(components.back());
        components.pop_back();
    }

    std::vector<Component> components;
};

class Registry
{
    struct EntityMetadata
    {
        bool has_components(Signature csig) const { return (csig & sig) == csig; }
        Signature sig;
        IndexedHierarchy<EntityId>::element_id hierarchy_key;
        uint32_t version{};
    };

    struct View
    {
        // checks if an entity with given signature has required components by the view
        bool test_sig(Signature esig) const { return (sig & esig) == sig; }
        Signature sig;
        std::vector<EntityId> entities;
        Signal<ViewEntityInsertedFunc> on_insert_callbacks;
        Signal<ViewEntityUpdatedFunc> on_update_callbacks;
        Signal<ViewEntityRemovedFunc> on_remove_callbacks;
    };

    // For internal use. Generated by some counter.
    using entity_t = uint32_t;
    inline static constexpr size_t MAX_ENTITY = ~entity_t{};

    template <typename... Components> static Signature get_signature()
    {
        return (ComponentTraits::get_signature<Components>() | ...);
    }

  public:
    bool has(EntityId eid) const { return slots.has(*eid.get_slot()) && eid.get_version() == get_md(eid).version; }
    template <typename... Components> bool has(EntityId eid) const
    {
        const auto sig = get_signature<Components...>();
        return has(eid) && (get_md(eid).sig & sig) == sig;
    }

    EntityId create()
    {
        const auto slot = SlotId{ slots.allocate() };
        if(!slot)
        {
            ENG_ASSERT(false, "Too many entities");
            return EntityId{};
        }
        if(*slot == metadatas.size()) { metadatas.emplace_back(); }
        auto& md = metadatas[*slot];
        const auto version = md.version;
        const auto eid = EntityId{ slot, version };
        md.hierarchy_key = hierarchy.insert(eid);
        return EntityId{ slot, version };
    }

    void erase(EntityId eid)
    {
        if(!has(eid))
        {
            ENG_ERROR("Tried to delete stale entity {}", *eid);
            return;
        }
        erase_components(eid);
        auto& md = get_md(eid);
        slots.erase(*eid.get_slot());
        hierarchy.erase(md.hierarchy_key);
        md = {};
        md.version = eid.get_version() + 1;
    }

    template <typename Component> Component& get(EntityId eid)
    {
        if(!has(eid))
        {
            static Component null_component = {};
            ENG_ERROR("Invalid entity {}", *eid);
            return null_component;
        }
        return get_pool<Component>().get(eid.get_slot());
    }

    template <typename... Components> void add_components(EntityId eid, Components&&... components)
    {
        if(!has(eid))
        {
            ENG_ERROR("Invalid entity {}", *eid);
            return;
        }

        const Signature sig = ComponentTraits::get_signature<Components...>();
        auto& md = get_md(eid);
        if((sig & md.sig).any())
        {
            ENG_ERROR("Entity {} already has some of these components {}", *eid, (sig & md.sig).to_string());
            return;
        }

        const auto emplace_component = [this, eid]<typename T>(auto&& comp) {
            auto& pool = get_pool<T>();
            pool.emplace(eid.get_slot(), std::forward<decltype(comp)>(comp));
        };
        const auto old_sig = md.sig;
        md.sig |= sig;
        (emplace_component.template operator()<Components>(std::forward<Components>(components)), ...);
        on_entity_sig_change(eid, old_sig, md.sig);
    }

    template <typename... Components> void erase_components(EntityId eid)
    {
        erase_components(eid, ComponentTraits::get_signature<Components...>());
    }

    template <typename... Components> void iterate_over_components(const auto& callback)
    {

        // const IComponentPool* const pool = try_find_smallest_pool<Components...>();
        // const Signature sig = get_signature<Components...>();
        // if(!pool) { return; }
        // for(auto e : pool->entities)
        //{
        //     if (metadatas[e].has_components(sig)) {

        //    }
        //}
    }

    void make_child(EntityId parentid, EntityId childid)
    {
        if(!has(parentid))
        {
            ENG_ERROR("Entity {} is invalid", *parentid);
            return;
        }
        if(!has(childid))
        {
            ENG_ERROR("Entity {} is invalid", *childid);
            return;
        }
        hierarchy.make_child(get_md(parentid).hierarchy_key, get_md(childid).hierarchy_key);
    }

    EntityId get_parent(EntityId eid) const
    {
        if(!has(eid))
        {
            ENG_ERROR("Entity {} is invalid", *eid);
            return EntityId{};
        }
        const auto p = hierarchy.get_parent(get_md(eid).hierarchy_key);
        if(!p) { return EntityId{}; }
        return hierarchy.at(p);
    }

    bool has_children(EntityId eid) const
    {
        if(!has(eid))
        {
            ENG_ERROR("Entity {} is invalid", *eid);
            return false;
        }
        const auto& md = get_md(eid);
        return (bool)hierarchy.get_first_child(md.hierarchy_key);
    }

    void loop_over_children(EntityId eid, const auto& callback)
    {
        if(!has(eid))
        {
            ENG_ERROR("Entity {} is invalid", *eid);
            return;
        }
        auto first = hierarchy.get_first_child(get_md(eid).hierarchy_key);
        if(!first) { return; }
        auto child = first;
        do
        {
            auto next = hierarchy.get_next_sibling(child);
            callback(hierarchy.at(child));
            child = next;
        }
        while(child != first);
    }

    void traverse_hierarchy(EntityId eid, const auto& callback)
    {
        if(!has(eid))
        {
            ENG_ERROR("Invalid entity {}", *eid.get_slot());
            return;
        }
        const auto traverse = [&](EntityId id, const auto& self) -> void {
            callback(id);
            loop_over_children(id, [&](EntityId id) { self(id, self); });
        };
        traverse(eid, traverse);
    }

    template <typename... Components>
    void register_callbacks(std::optional<Callback<ViewEntityInsertedFunc>> on_insert_callback = {},
                            std::optional<Callback<ViewEntityUpdatedFunc>> on_update_callback = {},
                            std::optional<Callback<ViewEntityRemovedFunc>> on_remove_callback = {})
    {
        auto& view = get_view(get_signature<Components...>());
        if(on_insert_callback) { view.on_insert_callbacks += *on_insert_callback; }
        if(on_update_callback) { view.on_update_callbacks += *on_update_callback; }
        if(on_remove_callback) { view.on_remove_callbacks += *on_remove_callback; }
    }

    template <typename... Components> void signal_components_update(EntityId eid)
    {
        notify_entity_views(eid, get_signature<Components...>());
    }

  private:
    EntityMetadata& get_md(EntityId eid) { return metadatas[*eid.get_slot()]; }
    const EntityMetadata& get_md(EntityId eid) const { return metadatas[*eid.get_slot()]; }

    void erase_components(EntityId eid, Signature sig)
    {
        if(!has(eid))
        {
            ENG_ERROR("Invalid entity {}", *eid.get_slot());
            return;
        }
        auto& md = get_md(eid);
        if((md.sig & sig).none()) { return; }
        for(auto i = 0ull; i < sig.size(); ++i)
        {
            if(sig[i]) { pools[i]->erase(eid.get_slot()); }
        }
        const auto newsig = md.sig & (~sig);
        if((md.sig & sig).any()) { on_entity_sig_change(eid, md.sig, newsig); }
        md.sig = newsig;
    }

    template <typename Component> ComponentPool<Component>& get_pool()
    {
        const auto id = ComponentTraits::get_id<Component>();
        if(!pools[id]) { pools[id] = std::make_unique<ComponentPool<Component>>(); }
        return *static_cast<ComponentPool<Component>*>(&*pools[id]);
    }

    View& get_view(Signature sig)
    {
        auto it = views.emplace(sig, View{});
        if(!it.second) { return it.first->second; }
        View& view = it.first->second;
        view.sig = sig;
        if(auto* smallest_component_pool = try_find_smallest_pool<Components...>())
        {
            for(auto e : smallest_component_pool->entities)
            {
                const auto eid = EntityId{ SlotId{ e }, metadatas[e].version };
                if(has<Components...>(eid)) { view.entities.push_back(eid); }
            }
        }
    }

    void on_entity_sig_change(EntityId eid, Signature old_sig, Signature new_sig)
    {
        for(auto& [viewsig, view] : views)
        {
            const auto old_sig_passed = view.test_sig(old_sig);
            const auto new_sig_passes = view.test_sig(new_sig);
            if(!old_sig_passed && new_sig_passes)
            {
                view.entities.push_back(eid);
                view.on_insert_callbacks.signal(eid);
            }
            else if(old_sig_passed && !new_sig_passes)
            {
                const auto rem = std::erase(view.entities, eid);
                ENG_ASSERT(rem == 1);
                view.on_remove_callbacks.signal(eid);
            }
        }
    }

    void notify_entity_views(EntityId eid, Signature updated_comps)
    {
        for(auto& [viewsig, view] : views)
        {
            if((updated_comps & view.sig).any() && view.test_sig(get_md(eid).sig))
            {
                view.on_update_callbacks.signal(eid, updated_comps);
            }
        }
    }

    template <typename... Components> IComponentPool* try_find_smallest_pool()
    {
        static_assert(sizeof...(Components) > 0);
        std::array<ComponentId, sizeof...(Components)> arr = { ComponentTraits::get_id<Components>()... };
        IComponentPool* smallest = &*pools[arr[0]];
        for(auto i = 1ull; i < arr.size(); ++i)
        {
            const auto idx = arr[i];
            if(!smallest || pools[idx]->entities.size() < smallest->entities.size()) { smallest = &*pools[idx]; }
        }
        return smallest;
    }

    IComponentPool* try_find_smallest_pool(Signature sig)
    {
        std::array<ComponentId, sizeof...(Components)> arr = { ComponentTraits::get_id<Components>()... };
        IComponentPool* smallest = &*pools[arr[0]];
        for(auto i = 1ull; i < arr.size(); ++i)
        {
            const auto idx = arr[i];
            if(!smallest || pools[idx]->entities.size() < smallest->entities.size()) { smallest = &*pools[idx]; }
        }
        return smallest;
    }

    SlotAllocator slots;
    std::vector<EntityMetadata> metadatas;
    IndexedHierarchy<EntityId> hierarchy;
    std::array<std::unique_ptr<IComponentPool>, MAX_COMPONENTS> pools;
    std::unordered_map<Signature, View> views;
};

} // namespace ecs
} // namespace eng

ENG_DEFINE_STD_HASH(eng::ecs::EntityId, *t);
ENG_DEFINE_STD_HASH(eng::ecs::SlotId, *t);