#version 460
#extension GL_EXT_nonuniform_qualifier : enable
#extension GL_EXT_scalar_block_layout : enable
#extension GL_EXT_buffer_reference : enable
#extension GL_EXT_shader_explicit_arithmetic_types_int32 : enable
#extension GL_EXT_shader_explicit_arithmetic_types_int64 : enable

layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

layout(binding = 1, set = 0, rgba8) uniform image2D image;
layout(binding = 2, set = 0, rgba8) uniform image2D ddgi_radiance_image;
layout(binding = 3, set = 0, rgba8) uniform image2D ddgi_irradiance_image;
layout(binding = 14, set = 0) uniform CameraProperties {
    mat4 viewInverse;
    mat4 projInverse;
    mat3 randomRotation;
} cam;
layout(binding = 15, set = 0) uniform sampler2D textures[];

#line       1        1 
struct Vertex {
    vec3 pos;
    vec3 nor;
    vec2 uv;
};

struct MeshData {
    //uint32_t index_offset;
    //uint32_t vertex_offset;
    uint32_t color_texture;
};

layout(scalar, buffer_reference, buffer_reference_align = 8) readonly buffer VertexBuffer {
    Vertex vertices[]; 
};
layout(scalar, buffer_reference, buffer_reference_align = 8) readonly buffer IndexBuffer {
    uint32_t indices[]; 
};
layout(scalar, buffer_reference, buffer_reference_align = 8) readonly buffer PerTriangleMeshId {
    uint32_t ids[];
};
layout(scalar, buffer_reference, buffer_reference_align = 8) readonly buffer MeshDatasBuffer {
    MeshData mesh_datas[];
};
layout(scalar, buffer_reference, buffer_reference_align = 8) readonly buffer PerTlasTriangleOffsets {
    uint32_t offsets[];
};
layout(scalar, buffer_reference, buffer_reference_align = 8) readonly buffer CombinedRTBuffers {
    PerTriangleMeshId mesh_ids;
    PerTlasTriangleOffsets offsets;
    MeshDatasBuffer meshes;
};

layout(scalar, buffer_reference, buffer_reference_align = 4) readonly buffer DDGIBuffer {
	vec3 probe_start;
	uvec3 probe_counts;
	vec3 probe_walk;
	float min_dist;
	float max_dist;
	float normal_bias;
	uint irr_res;
    uint rays_per_probe;
    uint radiance_tex_idx;
};

layout(scalar, push_constant) uniform Constants {
    CombinedRTBuffers combined_rt_buffs;
    VertexBuffer vertex_buffer;
    IndexBuffer index_buffer;
    DDGIBuffer ddgi;
    uint32_t mode;
};

#line     21        0 

const float PI = 3.1415926535897932;
const float EPSILON = 0.00001;

float signNotZero(float k) {
    return k >= 0.0 ? 1.0 : -1.0;
}

vec2 signNotZero(vec2 v) {
    return vec2( signNotZero(v.x), signNotZero(v.y) );
}

vec2 octEncode(in vec3 v) {
    float l1norm = abs(v.x) + abs(v.y) + abs(v.z);
    vec2 result = v.xy * (1.0/l1norm);
    if (v.z < 0.0) {
        result = (1.0 - abs(result.yx)) * signNotZero(result.xy);
    }
    return result;
}

vec3 octDecode(vec2 p) {
	float x = p.x, y = p.y;
    vec3 v = vec3(x, y, 1.0 - abs(x) - abs(y));
    if (v.z < 0) {
        v.xy = (1.0 - abs(v.yx)) * signNotZero(v.xy);
    }
    return normalize(v);
}

vec3 sphericalFibonacci(float i, float n) {
    const float PHI = sqrt(5.0) * 0.5 + 0.5;
#   define madfrac(A, B) ((A)*(B)-floor((A)*(B)))
    float phi = 2.0 * PI * madfrac(i, PHI - 1);
    float cosTheta = 1.0 - (2.0 * i + 1.0) * (1.0 / n);
    float sinTheta = sqrt(clamp(1.0 - cosTheta * cosTheta, 0.0, 1.0));

    return vec3(
        cos(phi) * sinTheta,
        sin(phi) * sinTheta,
        cosTheta);

#   undef madfrac
}

vec2 normalToUvRectOct(vec3 normal){
#if 1
    vec2 p = octEncode(normal);
	return (p * 0.5 + 0.5) * float(ddgi.irr_res);
#else
	float l1norm = abs(normal.x) + abs(normal.y) + abs(normal.z); 
	vec2 res = normal.xy * (1.0 / l1norm);
	if(normal.z < 0.0) {
		res = (1.0 - abs(res.yx)) * signNotZero(res.xy);
	}
	return res;
#endif
}

vec3 uvRectOctToNormal(vec2 normal) {
#if 0
	vec2 orig = normal.xy;
    float sum = dot(vec2(1.0), abs(normal.xy));

    if(sum > 1.0) {
        normal.xy = (1.0 - abs(normal.yx)) * sign(orig.xy);
    }
    float z = 1.0 - sum;
    
    return normalize(vec3(normal.xy, z));
#else 
	vec3 nor = vec3(normal, 1.0 - abs(normal.x) - abs(normal.y));
	float t = max(-nor.z, 0.0);
	nor.x += (nor.x > 0.0) ? -t : t;
	nor.y += (nor.y > 0.0) ? -t : t;
	return normalize(nor);
#endif
}

vec2 normalizedOctCoord(ivec2 coords) {	
	// this function should be called only when coords are not representing
	// border texels, and it assumes one texel border width around probe data
	// i.e. (x, y) == (1, 1) means bottom left texel that is non-border, so
	// -1 is applied to make it (0, 0)

	int probe_with_border = int(ddgi.irr_res) + 2;

#if 1
	coords = ivec2(4, 1);
	float x = float((coords.x - 1) % probe_with_border);
	float y = float((coords.y - 1) % probe_with_border);
	return (vec2(x, y) / float(ddgi.irr_res)) * 2.0 - 1.0;
#else 
	
	vec2 octFragCoord = ivec2( (coords - ivec2(1)) % probe_with_border );
	return (vec2(octFragCoord) + vec2(0.5)) * (2.0 / float(ddgi.irr_res)) - vec2(1.0, 1.0);
#endif
}

vec3 grid_coord_to_position(ivec3 grid_coords) {
    return ddgi.probe_start + vec3(grid_coords) * ddgi.probe_walk;
}

ivec3 get_probe_grid_coords(int probe_id) {
    ivec3 pos;
    pos.x = probe_id & (int(ddgi.probe_counts.x) - 1);
    pos.y = (probe_id & (int(ddgi.probe_counts.x) * int(ddgi.probe_counts.y) - 1)) >> findMSB(ddgi.probe_counts.x);
    pos.z = probe_id >> findMSB(ddgi.probe_counts.x * ddgi.probe_counts.y);
    return pos;
}

int get_probe_index_from_coords(ivec2 coords, int probe_with_border) {
	const ivec3 pc = ivec3(ddgi.probe_counts.xyz);
	const int x = (coords.x / probe_with_border) % pc.x;
	const int y = (coords.x / (probe_with_border * pc.x)) % pc.y;
	const int z = (coords.y / probe_with_border) % pc.z;
	return x + y*pc.x + z*pc.x*pc.y;
} 

const int k_read_table[] = int[](
    5, 3, 1, -1, -3, -5
);

const vec3 dirs[] = {
	vec3(-1.0, 0.0, 0.0),
	vec3( 1.0, 0.0, 0.0),
	vec3(-1.0, 0.0, 0.0),
	vec3( 1.0, 0.0, 0.0),
	vec3(-1.0, 0.0, 0.0),
	vec3( 1.0, 0.0, 0.0),
	vec3(-1.0, 0.0, 0.0),
	vec3( 1.0, 0.0, 0.0)
};

void main() {
#if 0
	imageStore(ddgi_irradiance_image, ivec2(gl_GlobalInvocationID.xy), vec4(0.0));
	return;
#endif
	
	const ivec2 coords = ivec2(gl_GlobalInvocationID.xy);
	const int probe_with_border = int(ddgi.irr_res) + 2;
	const int probe_last_pixel = int(ddgi.irr_res) + 1;
	const int probe_id = get_probe_index_from_coords(coords, probe_with_border);

	if(any(greaterThanEqual(coords, ivec2(ddgi.probe_counts.x * ddgi.probe_counts.y * probe_with_border, ddgi.probe_counts.z * probe_with_border)))) { return; }

	bool is_border_pixel = (
		   (gl_GlobalInvocationID.x % probe_with_border) == 0
		|| (gl_GlobalInvocationID.x % probe_with_border) == probe_last_pixel
		|| (gl_GlobalInvocationID.y % probe_with_border) == 0
		|| (gl_GlobalInvocationID.y % probe_with_border) == probe_last_pixel
	);

	if(!is_border_pixel) {
		vec4 result = vec4(0.0);
		uint num_backfaces = 0;
		uint max_backfaces = uint(ddgi.rays_per_probe * 0.1);

		for(int ray_idx = 0; ray_idx < ddgi.rays_per_probe; ++ray_idx) {
			ivec2 sample_pos = ivec2(ray_idx, probe_id);
#if 1
			vec3 ray_dir = sphericalFibonacci(float(ray_idx), float(ddgi.rays_per_probe));
#else 
			vec3 ray_dir = dirs[probe_id];
#endif
			vec2 uv_coord = normalToUvRectOct(ray_dir);
#if 1
			vec3 texel_dir = octDecode(normalizedOctCoord(coords));
#else
			//vec3 texel_dir = uvRectOctToNormal(normalizedOctCoord(coords, probe_with_border));
			vec3 texel_dir = vec3((normalizedOctCoord(coords, probe_with_border)), 0.0);
			//texel_dir = uvRectOctToNormal(texel_dir.xy);
#endif

			float weight = max(0.0, dot(texel_dir, ray_dir));
			weight = 1.0;

			if(weight >= EPSILON) {
				vec3 radiance = imageLoad(ddgi_radiance_image, sample_pos).rgb;
				//radiance = vec3(texel_dir);
				//radiance = vec3(uv_coord, 0.0);
				result += vec4(radiance * weight, weight); // TODO RADIANCE * ENERGY_CONSERVATION
			}
		}

		if(result.w > EPSILON) { result /= result.w; }
		imageStore(ddgi_irradiance_image, coords, vec4(result));
		return;
	} else { 
#if 0
		imageStore(ddgi_irradiance_image, coords, vec4(1.0)); 
		return; 
#endif
	}
     
    groupMemoryBarrier();
    barrier();

    const int probe_pixel_x = coords.x % probe_with_border;
    const int probe_pixel_y = coords.y % probe_with_border;
    bool is_corner_pixel = (
           (probe_pixel_x == 0 || probe_pixel_x == probe_last_pixel)
        && (probe_pixel_y == 0 || probe_pixel_y == probe_last_pixel)
    );
    bool is_row_pixel = (probe_pixel_x > 0 && probe_pixel_x < probe_last_pixel);
    ivec2 source_pixel_coord = coords;

    if(is_corner_pixel) {
        source_pixel_coord.x += probe_pixel_x == 0 ? int(ddgi.irr_res) : -int(ddgi.irr_res);
        source_pixel_coord.y += probe_pixel_y == 0 ? int(ddgi.irr_res) : -int(ddgi.irr_res);
    } else if(is_row_pixel) {
        source_pixel_coord.x += k_read_table[probe_pixel_x - 1];
        source_pixel_coord.y += (probe_pixel_y > 0) ? -1 : 1;
    } else {
        source_pixel_coord.x += (probe_pixel_x > 0) ? -1 : 1;
        source_pixel_coord.y += k_read_table[probe_pixel_y - 1];
    }

    vec4 copied_data = imageLoad(ddgi_irradiance_image, source_pixel_coord);
    imageStore(ddgi_irradiance_image, coords, copied_data);
}