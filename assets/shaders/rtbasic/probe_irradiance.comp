#version 460
#extension GL_EXT_nonuniform_qualifier : enable
#extension GL_EXT_scalar_block_layout : enable
#extension GL_EXT_buffer_reference : enable
#extension GL_EXT_shader_explicit_arithmetic_types_int32 : enable
#extension GL_EXT_shader_explicit_arithmetic_types_int64 : enable

layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

layout(binding = 1, set = 0, rgba8) uniform image2D image;
layout(binding = 2, set = 0, rgba8) uniform image2D ddgi_radiance_image;
layout(binding = 3, set = 0, rgba8) uniform image2D ddgi_irradiance_image;
layout(binding = 14, set = 0) uniform CameraProperties {
    mat4 viewInverse;
    mat4 projInverse;
    mat3 randomRotation;
} cam;
layout(binding = 15, set = 0) uniform sampler2D textures[];

struct Vertex {
    vec3 pos;
    vec3 nor;
    vec2 uv;
};

struct MeshData {
    //uint32_t index_offset;
    //uint32_t vertex_offset;
    uint32_t color_texture;
};

layout(scalar, buffer_reference, buffer_reference_align = 8) readonly buffer VertexBuffer {
    Vertex vertices[]; 
};
layout(scalar, buffer_reference, buffer_reference_align = 8) readonly buffer IndexBuffer {
    uint32_t indices[]; 
};
layout(scalar, buffer_reference, buffer_reference_align = 8) readonly buffer PerTriangleMeshId {
    uint32_t ids[];
};
layout(scalar, buffer_reference, buffer_reference_align = 8) readonly buffer MeshDatasBuffer {
    MeshData mesh_datas[];
};
layout(scalar, buffer_reference, buffer_reference_align = 8) readonly buffer PerTlasTriangleOffsets {
    uint32_t offsets[];
};
layout(scalar, buffer_reference, buffer_reference_align = 8) readonly buffer CombinedRTBuffers {
    PerTriangleMeshId mesh_ids;
    PerTlasTriangleOffsets offsets;
    MeshDatasBuffer meshes;
};

layout(scalar, buffer_reference, buffer_reference_align = 4) readonly buffer DDGIBuffer {
	vec3 probe_start;
	uvec3 probe_counts;
	vec3 probe_walk;
	float min_dist;
	float max_dist;
	float normal_bias;
	uint irr_res;
    uint rays_per_probe;
    uint radiance_tex_idx;
};

layout(scalar, push_constant) uniform Constants {
    CombinedRTBuffers combined_rt_buffs;
    VertexBuffer vertex_buffer;
    IndexBuffer index_buffer;
    DDGIBuffer ddgi;
    uint32_t mode;
};


const float PI = 3.1415926535897932;
const float EPSILON = 0.00001;

#include "probes.inc.glsl"

const int k_read_table[] = int[](
    5, 3, 1, -1, -3, -5
);

const vec3 dirs[] = {
	vec3(-1.0, 0.0, 0.0),
	vec3( 1.0, 0.0, 0.0),
	vec3(-1.0, 0.0, 0.0),
	vec3( 1.0, 0.0, 0.0),
	vec3(-1.0, 0.0, 0.0),
	vec3( 1.0, 0.0, 0.0),
	vec3(-1.0, 0.0, 0.0),
	vec3( 1.0, 0.0, 0.0)
};

void main() {
#if 0
	imageStore(ddgi_irradiance_image, ivec2(gl_GlobalInvocationID.xy), vec4(0.0));
	return;
#endif
	
	const ivec2 coords = ivec2(gl_GlobalInvocationID.xy);
	const int probe_with_border = int(ddgi.irr_res) + 2;
	const int probe_last_pixel = int(ddgi.irr_res) + 1;
	const int probe_id = get_probe_index_from_coords(coords);

	if(any(greaterThanEqual(coords, ivec2(ddgi.probe_counts.x * ddgi.probe_counts.y * probe_with_border, ddgi.probe_counts.z * probe_with_border)))) { return; }

	bool is_border_pixel = (
		   (gl_GlobalInvocationID.x % probe_with_border) == 0
		|| (gl_GlobalInvocationID.x % probe_with_border) == probe_last_pixel
		|| (gl_GlobalInvocationID.y % probe_with_border) == 0
		|| (gl_GlobalInvocationID.y % probe_with_border) == probe_last_pixel
	);

	if(!is_border_pixel) {
		vec4 result = vec4(0.0);
		uint num_backfaces = 0;
		uint max_backfaces = uint(ddgi.rays_per_probe * 0.1);

		for(int ray_idx = 0; ray_idx < ddgi.rays_per_probe; ++ray_idx) {
			ivec2 sample_pos = ivec2(ray_idx, probe_id);
#if 1
			vec3 ray_dir = sphericalFibonacci(float(ray_idx), float(ddgi.rays_per_probe));
#else 
			vec3 ray_dir = dirs[probe_id];
#endif
			vec2 uv_coord = normalToUvRectOct(ray_dir);
#if 1
			vec3 texel_dir = octDecode(normalizedOctCoord(coords));
			//texel_dir = vec3(normalizedOctCoord(coords), 1.0);
#else
			//vec3 texel_dir = uvRectOctToNormal(normalizedOctCoord(coords, probe_with_border));
			vec3 texel_dir = vec3((normalizedOctCoord(coords, probe_with_border)), 0.0);
			//texel_dir = uvRectOctToNormal(texel_dir.xy);
#endif

			float weight = max(0.0, dot(texel_dir, ray_dir));
			//weight = 1.0;

			if(weight >= EPSILON) {
				vec3 radiance = imageLoad(ddgi_radiance_image, sample_pos).rgb;
				//radiance = vec3(texel_dir);
				//radiance = vec3(uv_coord, 0.0);
				result += vec4(radiance * weight, weight); // TODO RADIANCE * ENERGY_CONSERVATION
			}
		}

		if(result.w > EPSILON) { result /= result.w; }
		imageStore(ddgi_irradiance_image, coords, vec4(result));
		return;
	} else { 
#if 0
		imageStore(ddgi_irradiance_image, coords, vec4(1.0)); 
		return; 
#endif
	}
     
    groupMemoryBarrier();
    barrier();

    const int probe_pixel_x = coords.x % probe_with_border;
    const int probe_pixel_y = coords.y % probe_with_border;
    bool is_corner_pixel = (
           (probe_pixel_x == 0 || probe_pixel_x == probe_last_pixel)
        && (probe_pixel_y == 0 || probe_pixel_y == probe_last_pixel)
    );
    bool is_row_pixel = (probe_pixel_x > 0 && probe_pixel_x < probe_last_pixel);
    ivec2 source_pixel_coord = coords;

    if(is_corner_pixel) {
        source_pixel_coord.x += probe_pixel_x == 0 ? int(ddgi.irr_res) : -int(ddgi.irr_res);
        source_pixel_coord.y += probe_pixel_y == 0 ? int(ddgi.irr_res) : -int(ddgi.irr_res);
    } else if(is_row_pixel) {
        source_pixel_coord.x += k_read_table[probe_pixel_x - 1];
        source_pixel_coord.y += (probe_pixel_y > 0) ? -1 : 1;
    } else {
        source_pixel_coord.x += (probe_pixel_x > 0) ? -1 : 1;
        source_pixel_coord.y += k_read_table[probe_pixel_y - 1];
    }

    vec4 copied_data = imageLoad(ddgi_irradiance_image, source_pixel_coord);
    imageStore(ddgi_irradiance_image, coords, copied_data);
}