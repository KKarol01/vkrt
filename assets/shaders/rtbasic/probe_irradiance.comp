#version 460
#extension GL_EXT_nonuniform_qualifier : enable
#extension GL_EXT_scalar_block_layout : enable
#extension GL_EXT_buffer_reference : enable
#extension GL_EXT_shader_explicit_arithmetic_types_int32 : enable
#extension GL_EXT_shader_explicit_arithmetic_types_int64 : enable

layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

#include "common.inc"
#include "descriptor_layout.inc"
#include "push_constants.inc"
#include "probes.inc.glsl"

const int k_read_table[] = int[](
    5, 3, 1, -1, -3, -5
);

const vec3 dirs[] = {
	vec3(-1.0, 0.0, 0.0),
	vec3( 1.0, 0.0, 0.0),
	vec3(-1.0, 0.0, 0.0),
	vec3( 1.0, 0.0, 0.0),
	vec3(-1.0, 0.0, 0.0),
	vec3( 1.0, 0.0, 0.0),
	vec3(-1.0, 0.0, 0.0),
	vec3( 1.0, 0.0, 0.0)
};

void main() {
#if 0
	imageStore(ddgi_irradiance_image, ivec2(gl_GlobalInvocationID.xy), vec4(0.0));
	return;
#endif
	
	const ivec2 coords = ivec2(gl_GlobalInvocationID.xy);
	const int probe_with_border = int(ddgi.irr_res) + 2;
	const int probe_last_pixel = int(ddgi.irr_res) + 1;
	const int probe_id = get_probe_index_from_coords(coords);

	if(any(greaterThanEqual(coords, ivec2(ddgi.probe_counts.x * ddgi.probe_counts.y * probe_with_border, ddgi.probe_counts.z * probe_with_border)))) { return; }

	bool is_border_pixel = (
		   (gl_GlobalInvocationID.x % probe_with_border) == 0
		|| (gl_GlobalInvocationID.x % probe_with_border) == probe_last_pixel
		|| (gl_GlobalInvocationID.y % probe_with_border) == 0
		|| (gl_GlobalInvocationID.y % probe_with_border) == probe_last_pixel
	);

	if(!is_border_pixel) {
		vec4 result = vec4(0.0);
		uint num_backfaces = 0;
		uint max_backfaces = uint(ddgi.rays_per_probe * 0.1);

		for(int ray_idx = 0; ray_idx < ddgi.rays_per_probe; ++ray_idx) {
			ivec2 sample_pos = ivec2(ray_idx, probe_id);
			vec3 ray_dir = sphericalFibonacci(float(ray_idx), float(ddgi.rays_per_probe));
			vec2 uv_coord = normalToUvRectOct(ray_dir);
			vec3 texel_dir = octDecode(normalizedOctCoord(coords));
			float weight = max(0.0, dot(texel_dir, ray_dir));
			vec4 read_radiance_distance = imageLoad(ddgi_radiance_image, sample_pos);
			vec3 radiance = read_radiance_distance.rgb;
			float dist = read_radiance_distance.w;

			if(dist < 0.0) {
				++num_backfaces;
				if(num_backfaces >= max_backfaces) { return; }
				continue;
			}

			if(mode == MODE_IRRADIANCE) {
				if(weight >= EPSILON) {
					radiance *= 0.95;
					result += vec4(radiance * weight, weight); 
				}
			} else if (mode == MODE_VISIBILITY) {
				weight = pow(weight, 2.5);

				if(weight >= EPSILON) {
					dist = min(abs(dist), ddgi.max_dist);
					result += vec4(dist * weight, dist * dist * weight, 0.0, weight);
				}
			}
		}

		if(result.w > EPSILON) { result /= result.w; }

		if(mode == MODE_IRRADIANCE) {
			imageStore(ddgi_irradiance_image, coords, result);
		} else if(mode == MODE_VISIBILITY) {
			
		}

		return;
	} else { 
#if 0
		imageStore(ddgi_irradiance_image, coords, vec4(1.0)); 
		return; 
#endif
	}
     
    groupMemoryBarrier();
    barrier();

    const int probe_pixel_x = coords.x % probe_with_border;
    const int probe_pixel_y = coords.y % probe_with_border;
    bool is_corner_pixel = (
           (probe_pixel_x == 0 || probe_pixel_x == probe_last_pixel)
        && (probe_pixel_y == 0 || probe_pixel_y == probe_last_pixel)
    );
    bool is_row_pixel = (probe_pixel_x > 0 && probe_pixel_x < probe_last_pixel);
    ivec2 source_pixel_coord = coords;

    if(is_corner_pixel) {
        source_pixel_coord.x += probe_pixel_x == 0 ? int(ddgi.irr_res) : -int(ddgi.irr_res);
        source_pixel_coord.y += probe_pixel_y == 0 ? int(ddgi.irr_res) : -int(ddgi.irr_res);
    } else if(is_row_pixel) {
        source_pixel_coord.x += k_read_table[probe_pixel_x - 1];
        source_pixel_coord.y += (probe_pixel_y > 0) ? -1 : 1;
    } else {
        source_pixel_coord.x += (probe_pixel_x > 0) ? -1 : 1;
        source_pixel_coord.y += k_read_table[probe_pixel_y - 1];
    }

    vec4 copied_data = imageLoad(ddgi_irradiance_image, source_pixel_coord);
    imageStore(ddgi_irradiance_image, coords, copied_data);
}