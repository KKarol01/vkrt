#version 460
#extension GL_EXT_nonuniform_qualifier : enable
#extension GL_EXT_scalar_block_layout : enable
#extension GL_EXT_buffer_reference : enable
#extension GL_EXT_shader_explicit_arithmetic_types_int32 : enable
#extension GL_EXT_shader_explicit_arithmetic_types_int64 : enable

layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

layout(binding = 1, set = 0, rgba8) uniform image2D image;
layout(binding = 2, set = 0, rgba8) uniform image2D ddgi_radiance_image;
layout(binding = 3, set = 0, rgba8) uniform image2D ddgi_irradiance_image;
layout(binding = 14, set = 0) uniform CameraProperties {
    mat4 viewInverse;
    mat4 projInverse;
    mat3 randomRotation;
} cam;
layout(binding = 15, set = 0) uniform sampler2D textures[];

#line       1        1 
struct Vertex {
    vec3 pos;
    vec3 nor;
    vec2 uv;
};

struct MeshData {
    //uint32_t index_offset;
    //uint32_t vertex_offset;
    uint32_t color_texture;
};

layout(scalar, buffer_reference, buffer_reference_align = 8) readonly buffer VertexBuffer {
    Vertex vertices[]; 
};
layout(scalar, buffer_reference, buffer_reference_align = 8) readonly buffer IndexBuffer {
    uint32_t indices[]; 
};
layout(scalar, buffer_reference, buffer_reference_align = 8) readonly buffer PerTriangleMeshId {
    uint32_t ids[];
};
layout(scalar, buffer_reference, buffer_reference_align = 8) readonly buffer MeshDatasBuffer {
    MeshData mesh_datas[];
};
layout(scalar, buffer_reference, buffer_reference_align = 8) readonly buffer PerTlasTriangleOffsets {
    uint32_t offsets[];
};
layout(scalar, buffer_reference, buffer_reference_align = 8) readonly buffer CombinedRTBuffers {
    PerTriangleMeshId mesh_ids;
    PerTlasTriangleOffsets offsets;
    MeshDatasBuffer meshes;
};

layout(scalar, buffer_reference, buffer_reference_align = 4) readonly buffer DDGIBuffer {
	vec3 probe_start;
	uvec3 probe_counts;
	vec3 probe_walk;
	float min_dist;
	float max_dist;
	float normal_bias;
	uint irr_res;
    uint rays_per_probe;
    uint radiance_tex_idx;
};

layout(scalar, push_constant) uniform Constants {
    CombinedRTBuffers combined_rt_buffs;
    VertexBuffer vertex_buffer;
    IndexBuffer index_buffer;
    DDGIBuffer ddgi;
    uint32_t mode;
};

#line     21        0 

const float PI = 3.1415926535897932;
const float EPSILON = 0.00001;

vec3 sphericalFibonacci(float i, float n) {
    const float PHI = sqrt(5.0) * 0.5 + 0.5;
#   define madfrac(A, B) ((A)*(B)-floor((A)*(B)))
    float phi = 2.0 * PI * madfrac(i, PHI - 1);
    float cosTheta = 1.0 - (2.0 * i + 1.0) * (1.0 / n);
    float sinTheta = sqrt(clamp(1.0 - cosTheta * cosTheta, 0.0, 1.0));

    return vec3(
        cos(phi) * sinTheta,
        sin(phi) * sinTheta,
        cosTheta);

#   undef madfrac
}

vec2 normalToUvRectOct(vec3 normal){
    vec2 p = normal.xy / dot(vec3(1.0), abs(normal));
    
    if(normal.z < 0.0) {
         p.xy = (1.0 - abs(p.yx)) * vec2(normal.x <= 0.0 ? -1 : 1, normal.y <= 0.0 ? -1 : 1);
    }
    
    p = clamp(p, vec2(-1.0), vec2(1.0));
	return (p * 0.5 + 0.5) * float(ddgi.irr_res);
}

vec3 uvRectOctToNormal(vec2 normal) {
	normal = normal / float(ddgi.irr_res) * 2.0 - 1.0;
	vec2 orig = normal.xy;
    float sum = dot(vec2(1.0), abs(normal.xy));

    if(sum > 1.0) {
        normal.xy = (1.0 - abs(normal.yx)) * sign(orig.xy);
    }
    float z = 1.0 - sum;
    
    return normalize(vec3(normal.xy, z));
}

vec2 normalizedOctCoord(ivec2 coords, int probe_with_border) {	
	// this function should be called only when coords are not representing
	// border texels, and it assumes one texel border width around probe data
	// i.e. (x, y) == (1, 1) means bottom left texel that is non-border, so
	// -1 is applied to make it (0, 0)
	float x = float((coords.x % probe_with_border) - 1);
	float y = float((coords.y % probe_with_border) - 1);
	return (vec2(x, y) / float(ddgi.irr_res - 1)) * 2.0 - 1.0;
}

vec3 grid_coord_to_position(ivec3 grid_coords) {
    return ddgi.probe_start + vec3(grid_coords) * ddgi.probe_walk;
}

ivec3 get_probe_grid_coords(int probe_id) {
    ivec3 pos;
    pos.x = probe_id & (int(ddgi.probe_counts.x) - 1);
    pos.y = (probe_id & (int(ddgi.probe_counts.x) * int(ddgi.probe_counts.y) - 1)) >> findMSB(ddgi.probe_counts.x);
    pos.z = probe_id >> findMSB(ddgi.probe_counts.x * ddgi.probe_counts.y);
    return pos;
}

int get_probe_index_from_coords(ivec2 coords, int probe_with_border) {
	const ivec3 pc = ivec3(ddgi.probe_counts.xyz);
	const int x = (coords.x / probe_with_border) % pc.x;
	const int y = (coords.x / (probe_with_border * pc.x)) % pc.y;
	const int z = (coords.y / probe_with_border) % pc.z;
	return x + y*pc.x + z*pc.x*pc.y;
} 

const int k_read_table[] = int[](
    5, 3, 1, -1, -3, -5
);

void main() {
#if 0
	imageStore(ddgi_irradiance_image, ivec2(gl_GlobalInvocationID.xy), vec4(0.0));
	return;
#endif
	
	const ivec2 coords = ivec2(gl_GlobalInvocationID.xy);
	const int probe_with_border = int(ddgi.irr_res) + 2;
	const int probe_last_pixel = int(ddgi.irr_res) + 1;
	const int probe_id = get_probe_index_from_coords(coords, probe_with_border);

	bool is_border_pixel = (
		   (gl_GlobalInvocationID.x % probe_with_border) == 0
		|| (gl_GlobalInvocationID.x % probe_with_border) == probe_last_pixel
		|| (gl_GlobalInvocationID.y % probe_with_border) == 0
		|| (gl_GlobalInvocationID.y % probe_with_border) == probe_last_pixel
	);

	if(!is_border_pixel) {
		vec4 result = vec4(0.0);
		uint num_backfaces = 0;
		uint max_backfaces = uint(ddgi.rays_per_probe * 0.1);

		for(int ray_idx = 0; ray_idx < ddgi.rays_per_probe; ++ray_idx) {
			ivec2 sample_pos = ivec2(ray_idx, probe_id);
			vec3 ray_dir = sphericalFibonacci(float(ray_idx), float(ddgi.rays_per_probe));
			vec3 texel_dir = uvRectOctToNormal((normalizedOctCoord(coords, probe_with_border) * 0.5 + 0.5) * ddgi.irr_res);
			float weight = max(0.0, dot(texel_dir, ray_dir));

			if(weight >= EPSILON) {
				vec3 radiance = imageLoad(ddgi_radiance_image, sample_pos).rgb;
				result += vec4(radiance * weight, weight); // TODO RADIANCE * ENERGY_CONSERVATION
			}
		}

		if(result.w > EPSILON) { result /= result.w; }
		imageStore(ddgi_irradiance_image, coords, result);
		return;
	}
     
    groupMemoryBarrier();
    barrier();

    const int probe_pixel_x = coords.x % probe_with_border;
    const int probe_pixel_y = coords.y % probe_with_border;
    bool is_corner_pixel = (
           (probe_pixel_x == 0 || probe_pixel_x == probe_last_pixel)
        && (probe_pixel_y == 0 || probe_pixel_y == probe_last_pixel)
    );
    bool is_row_pixel = (probe_pixel_x > 0 && probe_pixel_x < probe_last_pixel && probe_pixel_y == 0);
    ivec2 source_pixel_coord = coords;

    if(is_corner_pixel) {
        source_pixel_coord.x += probe_pixel_x == 0 ? int(ddgi.irr_res) : -int(ddgi.irr_res);
        source_pixel_coord.y += probe_pixel_y == 0 ? int(ddgi.irr_res) : -int(ddgi.irr_res);
    } else if(is_row_pixel) {
        source_pixel_coord.x += k_read_table[probe_pixel_x - 1];
        source_pixel_coord.y += (probe_pixel_y > 0) ? -1 : 1;
		vec4 copied_data = imageLoad(ddgi_irradiance_image, source_pixel_coord);
    } else {
        source_pixel_coord.x += (probe_pixel_x > 0) ? -1 : 1;
        source_pixel_coord.y += k_read_table[probe_pixel_y - 1];
    }

    vec4 copied_data = imageLoad(ddgi_irradiance_image, source_pixel_coord);
    imageStore(ddgi_irradiance_image, coords, copied_data);
}